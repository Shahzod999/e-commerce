const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch((error) => {
    res.status(500).json({ message: `${error.message} asyncHandler` });
  });
};

export default asyncHandler;

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// Зачем нужен asyncHandler?
// В асинхронных функциях (например, функциях, использующих async/await) ошибки, возникающие внутри await, могут не перехватываться автоматически Express, если их не обернуть в блок try/catch. Чтобы не писать блоки try/catch в каждом маршруте, используется asyncHandler, который перехватывает ошибки и передает их в обработчик ошибок Express.

// Пошаговый разбор кода:

// asyncHandler: Это функция, которая принимает другую функцию (fn) в качестве аргумента. Обычно fn — это асинхронная функция, которая будет использована в качестве middleware (промежуточной функции) для маршрутов Express.

// Возвращаемая функция: asyncHandler возвращает новую функцию, которая принимает три стандартных аргумента middleware в Express: req (запрос), res (ответ), и next (функция для передачи управления следующему middleware).

// Promise.resolve(fn(req, res, next)): Эта строка вызывает переданную функцию fn с аргументами req, res и next, и оборачивает её в Promise.resolve(). Это делает любую функцию (даже если она не возвращает промис) обрабатываемой как промис.

// catch((error) => {...}): Если в ходе выполнения fn возникает ошибка (например, неудачный запрос к базе данных или проблема с валидацией), catch перехватывает её и выполняет заданные действия. В данном случае:

// Ошибка обрабатывается путем отправки ответа с кодом состояния 500 (ошибка сервера) и сообщения с текстом ошибки.
